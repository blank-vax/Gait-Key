package SignalProcessing;
import org.fastica.*;
import java.util.Scanner;
import org.fastica.math.Matrix;

public class ica {
	/**
     *  @author b1ank-vax
     *  @description This part is the implement of fast independent analysis.
     *  @Attention: The value of input matrix is not supposed to be some continuous specific value, or it woule return the 1*k matrix
     *
     */
    
    // Return the inverse of the n*n matrix

	public static void Mrinv(double[][] a, int n) {
        int i, j, row, col, k;
        double max, temp;
        int[] p = new int[n];
        double[][] b = new double[n][n];
        for (i = 0; i < n; i++) {
            p[i] = i;
            b[i][i] = 1;
        }

        for (k = 0; k < n; k++) {
            // Finde the principal component
            max = 0;
            row = col = i;
            for (i = k; i < n; i++)
                for (j = k; j < n; j++) {
                    temp = Math.abs(b[i][j]);
                    if (max < temp) {
                        max = temp;
                        row = i;
                        col = j;
                    }
                }
            // Conduct the permutation of array and column, locate the principal component to row k and volumne k
            if (row != k) {
                for (j = 0; j < n; j++) {
                    temp = a[row][j];
                    a[row][j] = a[k][j];
                    a[k][j] = temp;
                    temp = b[row][j];
                    b[row][j] = b[k][j];
                    b[k][j] = temp;
                }
                i = p[row];
                p[row] = p[k];
                p[k] = i;
            }
            if (col != k) {
                for (i = 0; i < n; i++) {
                    temp = a[i][col];
                    a[i][col] = a[i][k];
                    a[i][k] = temp;
                }
            }
            for (j = k + 1; j < n; j++)
                a[k][j] /= a[k][k];
            for (j = 0; j < n; j++)
                b[k][j] /= a[k][k];
            a[k][k] = 1;

            for (j = k + 1; j < n; j++) {
                for (i = 0; i < k; i++)
                    a[i][j] -= a[i][k] * a[k][j];
                for (i = k + 1; i < n; i++)
                    a[i][j] -= a[i][k] * a[k][j];
            }
            for (j = 0; j < n; j++) {
                for (i = 0; i < k; i++)
                    b[i][j] -= a[i][k] * b[k][j];
                for (i = k + 1; i < n; i++)
                    b[i][j] -= a[i][k] * b[k][j];
            }
            for (i = 0; i < k; i++)
                a[i][k] = 0;
            a[k][k] = 1;
        }
        // Recover the order of ranks
        for (j = 0; j < n; j++)
            for (i = 0; i < n; i++)
                a[p[i]][j] = b[i][j];
    }
	
	public static double[][] getMM(double[][] acct) {
		FastICA fi = null;
		try {
            // Seperate the signal to 3 parts using fastica
			fi = new FastICA(acct, 3);
		} catch (FastICAException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        
        // Calculate the mix matrix A
		double[][] mm = fi.getMixingMatrix();
		
		return mm;
	}

    // Get rid of the influence to acceleration generated by swinging arms
    // Return the acceleration after elimination

	public static double[][] eliminateAS(double[][] rawData, double[][] unmixing){
		double[][] result;
		result = Matrix.mult(unmixing, rawData);
		for(int i = 0;i<result[1].length;i++) {
			result[1][i] = 0;
		}
		result = Matrix.mult(unmixing, result);
		return result;
	} 
			
	// Output the elements of matrix		
	public static void outputA(double[][] S) {
		System.out.println("S is a matrix with " + Matrix.getNumOfRows(S) + "rows and " + Matrix.getNumOfColumns(S) + "columns");
		for(int i =0;i<S.length;i++) {
			for(int j = 0;j<S[i].length;j++) {
				System.out.println("Result is: " + S[i][j]);
			}
		}
	}
	
}
